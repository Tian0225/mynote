<attachment contenteditable="false" data-atts="%5B%5D" data-aid=".atts-2865401e-6761-4033-a447-7159bdc0e0d7"></attachment><h2><a href="https://www.cnblogs.com/blueskyli/p/8326229.html" target="_blank" style="color: rgb(51, 51, 51);">ElasticSearch和solr的差别</a></h2><h3><br></h3><h3><strong>ElasticSearch vs Solr 总结</strong></h3><p><br></p><p><strong> </strong>（1）es基本是开箱即用，非常简单。Solr安装略微复杂一丢丢，可关注（<a href="http://www.cnblogs.com/blueskyli/p/7100443.html#3763227" target="_blank" style="color: rgb(0, 0, 0);">solr6.6教程-基础环境搭建(一)</a>）</p><p><strong>（</strong>2）Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。</p><p>（3）Solr 支持更多格式的数据，比如JSON、XML、CSV，而 Elasticsearch 仅支持json文件格式。</p><p>（4）Solr 官方提供的功能更多，而 Elasticsearch 本身更注重于核心功能，高级功能多有第三方插件提供，例如图形化界面需要kibana友好支撑</p><p>（5）Solr&nbsp;查询快，但更新索引时慢（即插入删除慢），用于电商等查询多的应用；</p><p>&nbsp;ES建立索引快（即查询慢），即实时性查询快，用于facebook新浪等搜索。</p><p>&nbsp;&nbsp;Solr 是传统搜索应用的有力解决方案，但 Elasticsearch 更适用于新兴的实时搜索应用。</p><p>（6）Solr比较成熟，有一个更大，更成熟的用户、开发和贡献者社区，而 Elasticsearch相对开发维护者较少，更新太快，学习使用成本较高。</p><p><br></p><p><br></p><h3>Live  业务了解 &amp; 技术栈在项目中的使用</h3><p><strong style="color: rgb(61, 70, 77);">项目介绍</strong><span style="color: rgb(61, 70, 77);">：</span></p><p><span style="color: rgb(61, 70, 77);">“一海游”是一个旅游产品服务的电商平台。 我在这边主要负责邮轮旅游模块和景点门票模块的开fa。 邮轮旅游模块主要负责后台对应新模块开fa以及根据UI图在项目查询出所需数据在前端页面展示。这边比较复杂的还是在数据库的设计上，因为每种邮轮底下有多个邮轮，每个邮轮又关联着许多子业务，有服务，美食，娱乐这些东西，然后每种子业务又有具体的东西。因为关系比较复杂，所以我在这边用了 Solr进行分布式搜索 来提高查询效率。新建了一个实体类继承Solr的抽象实体类，这个实体类主要放一些ID索引。还有一个服务类是用来对Solr实体进行一些操作。这样我们可以通过Solr进行快速查询，然先将查询到数据返回前端进行下一步操作。然后在景点门票这块，我们是通过接入第三方API进行二次销售。通过他们的API文档，传入API所需的参数，返回给我们数据，我们提取出所需数据导入数据库。这边做了一个定时器用于接口频次的控制，我们是控制在一分钟300次来保证数据的实时性。这边的下单也是接入他们的接口，由他们返回的信息来验证用户是否下单成功。</span></p><p><br></p><p><strong style="color: rgb(61, 70, 77);">业务场景：</strong></p><p><span style="color: rgb(61, 70, 77);">主营邮轮旅游，附加产品：景点门票，对接其他商家的接口API，ToBusiness 对商家的。</span></p><p><span style="color: rgb(61, 70, 77);">通过http请求这个网站，然后后台会请求数据，例如产品的库存，然后我们取出所需的字段存到我们数据库中，提取数据的话需要按照他们那边的接口文档，按照接口文档去调用，因为每家的数据接口都不一样，我们需要对接他们的接口格式然后去把我们需要的数据提取到数据库，然后再去展示再去售卖，这样就是说我们只相当于中间的东西，去取前面商家的数据，我们这边去调用后台的数据就没有再对数据做任何处理，因为我们要保证一个 原始数据</span></p><p><br></p><p>景点门票：</p><p><span style="color: rgb(61, 70, 77);">数据接口的调用</span></p><p><span style="color: rgb(61, 70, 77);">有设置一个定时器，他30s刷新一次，30s就会去刷新库存 两边要保持同步，30s会去请求接口，去刷新我们数据库的数据，保证我们数据库最新的数据</span></p><p><br></p><p><span style="color: rgb(61, 70, 77);">至于到下单的时候，因为页面数据跟他们的数据库真实数据可能有差异，中间隔了30s，所以我们下单的时候直接调用他们的接口去直接下单去减他们的库存，下单的时候与他们真正的库存去作比较，如果说不一样的话就下单失败 就没有当前商品，返回失败的信息反馈。因为不能保证商品有，商品数据的接口是他们提供的，我们下单的接口也是封装好后调用。</span></p><p><br></p><p><strong style="color: rgb(61, 70, 77);">游轮旅游模块场景：</strong></p><p><span style="color: rgb(61, 70, 77);">首先要保证到的航线有游轮，保证有航线后选择you轮，游轮选择之后有不同风格的定制化服务，餐厅，住宿。选择什么样的餐厅，</span></p><p>三个：服务  美食 住宿 娱乐</p><p><br></p><p><br></p><p><br></p><p><span style="color: rgb(61, 70, 77);">亮点：Solr  Memcached</span></p><ol><li>介绍一下solr</li><li>说一下solr的倒排索引：通过key找到value</li><li>二分法  ，常规查找和排序算法</li><li>为什么要使用solr</li><li>solr 和 elasticsearch 的都别</li><li><strong style="color: rgb(51, 51, 51);">传统搜索和实时搜索：</strong></li></ol><p><br></p><p>一、Solr</p><p>1. 介绍一下Solr？</p><p><span style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">Solr是一个Java开发的基于Lucene的&nbsp;企业级&nbsp;开源&nbsp;全文搜索&nbsp;平台。 它采用的是反向索引，即从关键字到文档的映射过程。 Solr的资源以Document为对象进行存储，每个文档由一系列的&nbsp;Field&nbsp;构成，每个Field&nbsp;表示资源的一个属性。 文档的Field可以被索引，&nbsp;以提工高性能的搜索效率。 一般情况下文档都包含一个能唯一表示该文档的</span><span style="color: rgb(215, 58, 73);">id</span><span style="color: rgb(51, 51, 51); background-color: rgb(246, 246, 246);">字段。</span></p><p><br></p><p><span style="color: rgb(51, 51, 51);">2.&nbsp;&nbsp;</span><span style="color: rgb(51, 51, 51); background-color: rgb(246, 246, 246);">说一下Solr的倒排索引</span></p><p><span style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">倒排索引就是从文档内容到文档序号的过程，将文档内容用solr自带分词器进行分词，然后作为索引，用二分法将关键字与排序号的索引进行匹配，进而查找到对应文档。（结合Live）</span></p><p><span style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">参考：</span><a href="https://blog.csdn.net/chunlei_zhang/article/details/38520315" target="_blank" style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">https://blog.csdn.net/chunlei_zhang/article/details/38520315</a></p><p><a href="https://blog.csdn.net/hu948162999/article/details/42463043" target="_blank" style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">https://blog.csdn.net/hu948162999/article/details/42463043</a></p><p><br></p><p><span style="color: rgb(51, 51, 51);">3.&nbsp;&nbsp;</span><span style="color: rgb(51, 51, 51); background-color: rgb(246, 246, 246);">既然2提到二分法，面试官有可能接下去问你数据结构算法的一些内容，可以去了解一下常用的查找算法和排序算法的实现及时间复杂度。</span></p><p><a href="https://blog.csdn.net/Sparkle_007/article/details/54971257" target="_blank" style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">https://blog.csdn.net/Sparkle_007/article/details/54971257</a></p><p><span style="background-color: rgb(246, 246, 246); color: rgb(51, 51, 51);">7大排序算法和查找算法是一定要掌握的！</span></p><p><br></p><p>4. 为什么要使用Solr?</p><p>当我们访问项目的邮轮旅游模块的热门航线搜索时的时候，我们可以根据我们随意所想的内容输入关键字就可以查询出相关的内容，这是怎么做到呢？这些随意的数据不可能是根据数据库的字段查询的，那是怎么查询出来的呢，为什么千奇百怪的关键字都可以查询出来呢？</p><p>答案就是全文检索工具的实现，luncence采用了词元匹配和切分词。举个例子：厦门-日本----luncence切分词：厦门&nbsp;日本&nbsp;厦日&nbsp;日门&nbsp;等等这些分词。所以我们搜索的时候都可以检索到。</p><p>有一种分词器就是IKanalyzer中文分词器，它有细粒度切分和智能切分，即根据某种智能算法。</p><p>这就使用solr的最大的好处：检索功能的实现。</p><p><br></p><p><span style="color: rgb(51, 51, 51);">5.&nbsp;&nbsp;&nbsp;&nbsp;</span>Solr和<span style="color: rgb(51, 51, 51);">elasticsearch的区别？</span></p><p><span style="color: rgb(51, 51, 51);">共同点：solr和elasticsearch都是基于Lucene实现的！</span></p><p><br></p><p><span style="color: rgb(51, 51, 51);">不同点：</span></p><p><span style="color: rgb(51, 51, 51);">A. solr利用zookeeper进行分布式管理，而elasticsearch自身带有分布式协调管理功能；</span></p><p><span style="color: rgb(51, 51, 51);">B. solr比elasticsearch实现更加全面，solr官方提供的功能更多，而elasticsearch本身更注 重于核心功能，高级功能多由第三方插件提供；</span></p><p><span style="color: rgb(51, 51, 51);">C. solr在传统的搜索应用中表现好于elasticsearch，而elasticsearch在实时搜索应用方面比solr表现好！</span></p><p><strong style="color: rgb(51, 51, 51);">最后有必要说明一下传统搜索和实时搜索：</strong></p><p><strong style="color: rgb(51, 51, 51);">传统搜索是从静态数据库中筛选出符合条件的结果，这种结果往往是不可变得、静态的。而实时搜索则是说用户对于搜索的结果是实时变化的。</strong></p><p><strong style="color: rgb(51, 51, 51);">传统搜索比如电商这种，实时搜索参考谷歌，百度，这种实时搜索。</strong></p><p>&nbsp;</p><p>Memcached：</p><p>1.&nbsp;&nbsp;&nbsp;&nbsp;简介Memcached</p><p><span style="color: rgb(51, 51, 51);">memcached是高性能的分布式内存缓存服务器。它通过缓存数据库查询结果，减少数据库访问次数，以提高动态Web应用的速度、提高可扩展性。memcached的API使用32位元的循环冗余校验（CRC-32）计算键值后，将资料分散在不同的机器上。当表格满了以后，接下来新增的资料会以LRU机制替换掉。Memcached基于一个存储键/值对的hashmap。其守护进程（daemon）是用C写的，但是客户端可以用任何语言来编写，并通过memcached协议与守护进程通信</span></p><h4>2. <span style="color: rgb(47, 47, 47);">Memcached的分布式算法</span></h4><p><span style="color: rgb(47, 47, 47);">A. </span>余数哈希：<span style="color: rgb(47, 47, 47);">根据服务器台数的余数进行哈希,求得键的哈希值,再处理服务器台数,根据余数选择服务器,</span></p><p><span style="color: rgb(47, 47, 47);">缺点:当添加或者移除服务器时,缓存重组的代价太大,</span></p><p><span style="color: rgb(47, 47, 47);">当添加服务器,要进行重哈希，会导致原来的服务器序号变了，下一次找不到，访问数据,Memcached命中率下降,那么就增加了数据库服务器的负载.</span></p><p>B. 一致性哈希：<strong style="color: rgb(47, 47, 47);">一致性哈希是将整个哈希值空间组织成一个虚拟的圆环,如假设某哈希函数H的值空间是0~(2^32 -1)(即哈希值是一个32位的无符号整型),这个哈希空间为环。然后让每台机器占一个扇形空间。</strong></p><p>&nbsp;</p><p><br></p><p><strong style="color: rgb(47, 47, 47);">举个例子：余数哈希相当于一个萝卜一个坑，刚刚好，这时候在中间新挖一个坑，下一次去拿的时候会按照原有逻辑，会导致最后一个有萝卜的坑没被拿到丢了。一致性哈希就是这100米内都来这个坑挖，100米之后的去下一个坑，这时候新挖一个坑，重新调整一些空间给新的坑就行，不至于数据全部丢失。</strong></p><p><br></p><p><strong style="color: rgb(47, 47, 47);">3.&nbsp;&nbsp;Memcached的数据清除算法？</strong></p><p><span style="color: rgb(51, 51, 51);">LRU。每个slab会维护一个队列，刚插入的数据在队头，经常get的数据也会移动到队头，这样较老或者访问较少的数据相对都留在队尾。该算法从队尾开始淘汰。当slab分配不到足够的内存时，首先</span><span style="color: rgb(112, 48, 160);">会检查队尾是否有过期数据</span><span style="color: rgb(51, 51, 51);">。如果有的话会直接将其覆盖为新的对象，如果没有，会开始淘汰队尾的对象。</span></p><p><br></p><p><span style="color: rgb(85, 85, 85);">Slab是一个内存块，它是memcached一次申请内存的最小单位。Slab的大小固定为1M（1048576 Byte），一个slab由若干个大小相等的chunk组成。每个chunk中都保存了一个item结构体、一对key和value。</span></p><p><img src="//:0" alt="IMG_256" height="285" width="428"></p><p><br></p><p>4.&nbsp;&nbsp;描述一下Memcacehd的工作流程</p><p><span style="color: rgb(68, 68, 68);">先检查客户端的请求数据是否在memcached中，如有，直接把请求数据返回，不再对数据库进行任何操作；如果请求的数据不在memcached中，就去查数据库，把从数据库中获取的数据返回给客户端，同时把数据缓存一份到memcached中（memcached客户端不负责，需要程序明确实现）；每次更新数据库的同时更新memcached中的数据，保证一致性；当分配给memcached内存空间用完之后，会使用LRU（Least Recently Used，最近最少使用）策略加上到期失效策略，失效数据首先被替换，然后再替换掉最近未使用的数据。</span></p><p><br></p><p>5.&nbsp;<span style="color: rgb(68, 68, 68);">Memcached 和 Redis的区别？</span></p><p><span style="color: rgb(51, 51, 51);"> </span></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;</span>1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供<span style="background-color: rgb(248, 248, 248); color: rgb(102, 102, 102);">string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）</span>等数据结构的存储。memcache支持简单的数据类型，String。</p><p>2 、Redis支持数据的备份，即master-slave模式的数据备份。</p><p>3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中</p><p>4、 redis的速度比memcached快很多</p><p>5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。</p><p><br></p><p><span style="color: rgb(51, 51, 51);">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span style="color: red;">小结：，有持久化需求或者对数据结构和处理有高级要求的应用，选择redis，其他简单的key/value存储，选择memcached。</span><span style="color: rgb(51, 51, 51);">对于两者的选择需要要看具体的应用场景，如果需要缓存的数据只是key-value这样简单的结构时，则还是采用memcache，它也足够的稳定可靠。如果涉及到存储，排序等一系列复杂的操作时，毫无疑问选择redis。</span></p><p><br></p><p>二、Spring（这个我没被问到，但是我找了个比较好的资源供大家参考）</p><p>http://www.importnew.com/15851.html</p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>