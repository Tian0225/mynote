###  目前该项目的学习不要求看代码，不要求技术实现细节，更多的是能应付面试官的面试。
###  面试通过之后联系我，针对入职前进行框架实战学习，这时候注重框架使用和一些实战。

1. 注意事项：不建议将项目名称和简历上的描述一字不漏照抄，避免重复，发挥自己想象力，进行修改。写简历时别把项目链接直接往简历写，避免面试官打开网页，追着问。直接说项目还没上线，然后项目名和项目介绍就可以自己写。

2. 可将项目作为实习项目，实验室导师分发项目，或者自己接的外包项目书写。（需要这 部分私聊我）

3. 该项目建议与项目三一起整合为大数据后台项目，问点较多且不会被深究。

4. Live中会有一个项目的业务场景介绍，还有框架在项目中的业务应用场景介绍。
Live：
https://m.qlchat.com/topic/2000003506126856.htm（付款之后找群主退款，收取10元平台手续费。。）听完Live，有哪个地方不理解的，整理一下，然后发我微信进行解答。

5. 该项目重点抓住Zookeeper，然后Dubbo与ZK的关系，其次就是RabbitMQ和Redis。因为我是面大数据，所以没被问过Spring，但我在后面也会为准备后台面试的同学整理一些Spring重点。

6. ZK live：https://m.qlchat.com/topic/2000002824050113.htm（付款之后找我退款）多听几遍。

7. 学到什么时候可以去面试？
听完项目二和zk的live，能理解我Live讲的内容就可以写在简历上进行投递了。不要等全部懂了再去写简历投！不要等全部懂了再去写简历投！不要等全部懂了再去写简历投！面试中更能暴露出你的问题，面试完再补缺补漏就行。

8. 面试完自己得及时回顾一下，在面试中暴露出的问题自己想不通的可以整理一下发我进行解答。

9. 文档会持续更新，每隔段时间或者有较为重要的更新时会主动给你们发，你们发现缺什么或者需要什么也可以跟我提。


一、项目介绍及简历书写
项目介绍：
“优茶联”是一个B2B，B2C的茶电商平台。这个项目是由SpringMVC框架搭建的，将系统分成多层进行解耦合。因为业务服务比较多，所以这边用了Dubbo分布式服务框架来进行协调不同层次之间的服务调用。而Dubbo组件中有一个Registry也就是注册中心，我们这边选了Zookeeper作为Dubbo服务的注册中心，进行服务的注册和订阅。然后平时会搞一些促销活动，并发量会比较大，所以这边用RabbitMQ消息队列进行消息的传递，避免数据库压力过大，也保证了用户使用过程的顺畅性。我在项目中主要负责的是微信商城的订单模块的后台开发。后台开发时遇到的困难就是创建预售订单的业务问题，后来通过网上看了人人都是产品经理的文章里面的一张架构流程图，然后我这边就设定预售商品和普通商品不能同时创建订单，预售商品不加入购物车，不走库存。
 

从0到1订单系统设计思路：http://www.woshipm.com/pd/1392102.html


项目背景：优茶联是一个 B2B，B2C 的电商平台，它以消费者为中心，充分利用大数据建立全流程线上线下一体化商业系统，是
一个能够解决用户多重茶叶需求的工具。项目中主要用到的技术栈有 Spring,Dubbo,Zookeeper,RabbitMQ,Redis 等。
工作任务：商家地图模块的新需求，参与订单模块的开发，B2B 的部分接口。
完成情况：在规定的时间内，独立完成了商家地图模块以及协助技术组长完成了订单模块，以供用户进行搜索商家并完成下单等
操作，并在微信商城如期上线。完成了前端同事的 B2B 接口文档内容，并修补了部分测试的 bug，使得 App 客户端的 B2B 模块流程
走通，并如期上线。
商家地图模块项目地址：http://b2c.youchalian.com/weixinfront/static/home_map.html?share=0&id=0&storeId=0&flag =T&channel=map_store

二、Zookeeper(听Live)
1.	简述ZAB协议以及Zookeeper?（面经p13）
2.	简述Paxos算法（p16)
3.	Zookeeper的某个机器挂了，整个集群如何处理？(p44)
4.	简述ZK的fastleaderelection选举leader的算法（p44）
5.	ZK如何保证数据的一致性？（p58）

三、Dubbo（https://dubbo.gitbooks.io/dubbo-user-book/ 好好看看，内容不多）
1.	介绍一下Dubbo?
Dubbo是一个分布式服务框架，以及SOA治理方案。其功能主要包括：高性能NIO通讯及多协议集成，服务动态寻址与路由，软负载均衡与容错，依赖分析与降级等。 它有5个节点，分别是Provider, Consumer, Registry, Monitor, Container。其中Provider是服务提供者， Consumer是服务消费者，Registry是服务进行注册和被发现的注册中心，Monitor是统计服务的调用次数和调用时间的监控中心，Container是服务运行容器。他们之间调用的关系是：Container负责启动，加载然后运行Provider。Provider在启动时会向注册中心注册自己提供的服务，Consumer在启动时会向Registry订阅自己所需服务，此时Registry会返回Provider地址列表给Consumer。如果地址有变更，Registry会基于长连接推送变更数据给Consumer。Consumer会基于软负载均衡算法选一台提供者进行调用，如果调用失败，则再选一台。Provider和Consumer在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到Monitor。 Dubbo具有4个特点，分别是连通性、jian壮性、伸缩性、以及向未来架构的升级性。连通性说明他们之间都存在着关系，比如说Provider,Consumer和Registry三者之间都是长连接，而Provider，Consumer向Registry注册服务以及订阅服务的时间都得向Monitor汇报。而jian壮性说明具有稳定性，比如说注册中心对等集群中的任意一台宕掉后，将自动切换到另一台。就算注册中心全部宕掉，服务者和消费者仍可以通过本地缓存进行通讯。而伸缩性就是可以通过增加机器部署实例进行添加新的注册中心和服务提供者。而升级性是文档中提到的对未来架构的设想，比起目前框架它的特点是可以实现自动部署服务的本地代理以及可以通过访问压力来自动增减服务提供者。 
 
 

调用关系说明：
1. 服务容器负责启动，加载，运行服务提供者。
2. 服务提供者在启动时，向注册中心注册自己提供的服务。
3. 服务消费者在启动时，向注册中心订阅自己所需的服务。
4. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
5. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
6. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

2.	当zk作为dubbo的注册中心时，是怎么工作的？
Zookeeper作为Dubbo的注册中心时：服务提供者在初始化启动时，会在Zookeeper下的Dubbo节点下的服务节点下的providers节点下的节点创建一个子节点并写入URL，路径类似为 /dubbo/servicename/providers/ ，该路径下的所有子节点均为服务提供者。此时这些子节点都为临时节点，因为临时节点的生命周期与客户端会话相关，所以一旦提供者所在的机器出现故障导致提供者无法提供服务，该临时节点就会自动从Zookeeper删除。此时因为服务者，注册中心，消费者之间是长连接，注册中心能感知服务者宕机，会告知消费者。而监控中心是Dubbo服务治理体系中重要的一部分，它需要知道所有的服务提供者和消费者的变化情况 。所以它在启动时会在服务节点上注册一个watcher来监听子节点变化，路径为 /dubbo/servicename/ ，所以它也能感知服务提供者的宕机。服务消费者的节点创建过程和提供者是一样的，而且也是临时结点。还有一个特性就是Zookeeper的节点结构设计，它以服务名和类型，也就是 /dubbo/servicename/类型 作为节点路径，符合Dubbo订阅和通知的需求，保证了以服务为粒度的变更通知，通知范围易于控制。所以即使服务提供者和消费者频繁变更，对Zookeeper的性能也不会造成多大影响。
三、RabbitMQ
1. 什么是RabbitMQ?
RabbitMQ 即一个消息队列，主要是用来实现应用程序的异步和解耦，同时也能起到消息缓冲，消息分发的作用。RabbitMQ使用的是AMQP协议，它是一种二进制协议。

2. 为什么要使用RabbitMQ?(https://mp.weixin.qq.com/s/3GMs3ae7ffDFgia9VSDMEg)
从应用场景去回答，live中会讲到。

3. 消息队列的优缺点？
优点就是在特殊场景下有其对应的好处，解耦、异步、削峰。（参考2）
缺点有以下几个：
1.系统可用性降低
系统引入的外部依赖越多，越容易挂掉。本来你就是 A 系统调用 BCD 三个系统的接口就好了，人 ABCD 四个系统好好的，没啥问题，加个 MQ 进来，万一 MQ 挂了可能整套系统就都崩溃。
2.系统复杂度提高
加个 MQ 进来，要保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
3.一致性问题
A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致了。
4. Kafka 与 RabbitMQ的区别？
https://juejin.im/post/5acf29316fb9a028cb2e04ce
从吞吐量，消息的可靠性，以及重量级（就是使用起来方不方便，适合什么系统）来说明即可。

四、Redis
1. 什么是redis？
Redis 是一个使用 C 语言写成的，开源、支持网络、基于内存、可选持久性的、非关系型，key-value数据库。它是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。

2. Redis 与 memcached的区别和比较？
1 、Redis不仅仅支持简单的k/v类型的数据，同时还提供string(字符串)、list(链表)、set(集合)、zset(sorted set --有序集合)和hash（哈希类型）等数据结构的存储。memcache支持简单的数据类型，String。
2 、Redis支持数据的备份，即master-slave模式的数据备份。
3 、Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中
4、 redis的速度比memcached快很多
5、Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的IO复用模型。

3. 使用redis的好处？
(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)
(2)支持丰富数据类型，支持string，list，set，sorted set，hash
(3) 支持事务 ：redis对事务是部分支持的，如果是在入队时报错，那么都不会执行；在非入队时报错，那么成功的就会成功执行。
redis监控：锁的介绍
(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除。

4. Redisn内存回收算法？
LRU和引用计数器算法。https://www.cnblogs.com/WJ5888/p/4371647.html
5. Redis有哪几种数据淘汰策略？ 
noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外） 
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。 
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。 
allkeys-random: 回收随机的键使得新添加的数据有空间存放。 
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。 
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。


五、Spring（这个我没被问到，但是我找了个比较好的资源供大家参考）
http://www.importnew.com/15851.html






